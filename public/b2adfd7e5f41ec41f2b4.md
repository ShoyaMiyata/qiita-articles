---
title: GoogleのロゴでHTTPリクエストとレスポンスを確認する
tags:
  - HTTP
  - Web
  - AdventCalendar2024
private: false
updated_at: '2024-12-17T15:13:43+09:00'
id: b2adfd7e5f41ec41f2b4
organization_url_name: lmi-inc
slide: false
ignorePublish: false
---
## はじめに

こんにちは！リンクアンドモチベーションの宮田です！

本記事は[リンクアンドモチベーション Advent Calendar 2024](https://qiita.com/advent-calendar/2024/lmi)の16日目を担当しています🎄

最近[イラスト図解式 この一冊で全部わかるWeb技術の基本 第2版](https://www.amazon.co.jp/%E3%82%A4%E3%83%A9%E3%82%B9%E3%83%88%E5%9B%B3%E8%A7%A3%E5%BC%8F-%E3%81%93%E3%81%AE%E4%B8%80%E5%86%8A%E3%81%A7%E5%85%A8%E9%83%A8%E3%82%8F%E3%81%8B%E3%82%8BWeb%E6%8A%80%E8%A1%93%E3%81%AE%E5%9F%BA%E6%9C%AC-%E7%AC%AC2%E7%89%88-NRI%E3%83%8D%E3%83%83%E3%83%88%E3%82%B3%E3%83%A0%E6%A0%AA%E5%BC%8F%E4%BC%9A%E7%A4%BE/dp/4815625948/ref=pd_lpo_d_sccl_1/355-3933582-3424357?pd_rd_w=AhJhX&content-id=amzn1.sym.855d8f70-df76-4181-80b0-56e48ae3bb9b&pf_rd_p=855d8f70-df76-4181-80b0-56e48ae3bb9b&pf_rd_r=D307NJM85KB10QAVWPWR&pd_rd_wg=weMQa&pd_rd_r=0de1d0a3-8e1c-4643-b540-6301b89668eb&pd_rd_i=4815625948&psc=1
)を読んだのですが、自分でも実際に手を動かして理解を深めようということで、今回は以下の画像（[Googleの検索画面のロゴ](https://www.google.co.jp/)）がどのようにブラウザに取得されているのか、またその際の**HTTPリクエストとHTTPレスポンス**に含まれる情報について調べてみました。


![image.png](https://www.google.co.jp/images/branding/googlelogo/2x/googlelogo_color_272x92dp.png)

### ↑↑　こいつの裏側で何が動いているのか👀




## まずHTTPとは
実際にGoogleのロゴを見る前に、ざっくりHTTPについて確認していきます。
HTTPとは **Hyper Text Transfer Protocol**の略で、**WebブラウザとWebサーバー間でWeb情報をやりとりするためのプロトコル（通信規則）** です。
ウェブの基盤となる技術であり、ウェブページの取得やデータ送信など、インターネット上の多くのサービスに利用されています。




**HTTPの特徴**
HTTPは**ステートレス（stateless）** なプロコトルと言われていて、
各リクエストは独立して処理され、過去のリクエスト情報を保持しません。というのは、言い換えると個々のクライアントの情報を持たないということです。
このおかげで、複数の問い合わせに対する処理を効率的に行うことができています。
**リクエスト処理マシーンになれるということですね。**　
ただ、実現したいサービスによってはステートレスがあだとなるパターンもありそうだということは意識しておきたいです。

:::note info　
**HTTP**
- WebブラウザとWebサーバー間でWeb情報をやりとりするためのプロトコル
- ステートレス（個別の情報をもたない）
:::


## HTTPリクエスト
WebブラウザからWebサーバーに送られるもので以下のような構成になっています。

| リクエストライン        |
|------------------------
| **HTTPヘッダー**           |
| **空行**                 |
| **メッセージボディ**        |


HTTPリクエストの最初の行のリクエストラインで、サーバーに対して行う操作（メソッド）や対象のリソース、通信プロトコルのバージョンを指定します。

    # HTTPリクエストライン
    
    GET/index.html/HTTP/1.1
    
    メソッド/パス名/バージョン

:::note info
「**クライアントがサーバーに対して、HTTPバージョン1.1を使用して /index.html というファイルを取得するリクエストを送信する。**」
:::

## HTTPレスポンス
WebサーバーからWebブラウザに送られるもので、以下のような構成になっています。

| ステータスライン        |
|------------------------
| **HTTPヘッダー**           |
| **空行**                 |
| **メッセージボディ**        |


    HTTPレスポンス　ステータスライン
    
    HTTP/1.1/200/OK
    
    バージョン/ステータスコード/テキストフレーズ


バージョンってなんだ、ステータスってなんだ、という場合は簡単にまとめてみたので以下を確認してみましょう。

## **HTTPのバージョン**
#### **1. HTTP/1.1**
- 最も普及しているバージョン
  - パイプライン（複数リクエストを同時に送信）
  - キャッシュ制御の強化（`Cache-Control`）

もともとはリクエストを送信したらそのレスポンスが返ってくるまで、次のリクエストを送信することはできませんでしたが、パイプラインのおかげでリクエストを複数同時送信できるようになりました。しかし、送った順番にリクエストを処理するので、一つ詰まると処理が止まってしまうのが弱点です。

#### **2. HTTP/2**
- HTTP/1.1の課題（遅延や帯域幅の無駄）を解消
  - バイナリプロトコル：効率的なデータ送信
  - マルチプレキシング：複数リクエストを同時に処理
  - ヘッダー圧縮：通信量を削減。差分を送信するみたいな手法

HTTP/1.1の弱点を補うように、マルチプレキシング（ストリーム処理）によって複数のリクエスト→レスポンスを並列で処理できるようになりました。

#### **3. HTTP/3**
- 新しいプロトコルで、**QUIC**（UDPベース）を採用。
  - 接続の高速化。

## ステータスコード
ステータスコードはクライアントからサーバーのリクエストに対して、サーバーがどのように処理したかを数字で伝える仕組み。以下のような種類があります。
| ステータスコード | カテゴリ          | 説明                                                      |
|------------------|-------------------|-----------------------------------------------------------|
| **1XX**          | Continue          | リクエスト中                                               |
| **200**          | OK                | リクエストが正常に処理されたことを通知する                 |
| **3XX**          | Redirection       | リダイレクト                                              |
| 301              | Moved Permanently | リクエストされたコンテンツが移動したことを通知            |
| 302              | Found             | リクエストされたコンテンツが一時的に移動したことを通知    |
| 303              | See Other         | リクエストされたコンテンツが未更新であることを通知する    |
| 304              | Not Modified      | クライアントが以前に取得したリソースが変更されていないことを示し、キャッシュされたリソースを再利用する |
| **4XX**          | Client Error      | クライアントエラー                                        |
| 400              | Bad Request       | リクエストが不正                                          |
|401|Unauthorized|認証情報が得られない
| 403              | Forbidden         | コンテンツへのアクセス権がないことを通知                  |
| 404              | Not Found         | リクエストしたコンテンツが未検出であることを通知          |
| **5XX**          | Server Error      | サーバーエラー                                            |
| 500              | Internal Server Error | リクエスト処理中にサーバー内部でエラーが発生したことを通知 |
|502|Bad Gateway|有効な応答を受け取れなかった場合に発生
| 503              | Service Unavailable | アクセス集中やメンテナンスなどの理由で一時的に処理不可であることを通知 |



## 開発者ツールで見てみる

Googleの画面で開発者ツールを開いてみて、
![image.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/3924509/b9562bc5-7e35-4576-aa89-ff234dc729e8.png)

Googleのロゴの情報を取得している部分を確認してみます。

**全般**：概要を表示してくれている感じでしょうか

![image.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/3924509/264e9e4e-92e0-6a2e-bc68-3f11a2d45b71.png)

上から確認していきます。

---
**要求URL（リクエストURL） :**
 ``https://www.google.co.jp/images/branding/googlelogo/2x/googlelogo_color_272x92dp.png``


 どんな構造かというと、

    # スキーム
    https://

    # ドメイン（ホスト）
    www.google.co.jp

    # パス
    /images/branding/googlelogo/2x/googlelogo_color_272x92dp.png

- **スキーム**とはURLの先頭につく要素で、**「どのプロトコルを使って通信をするのか」** を指定する役割を持っています。

プロコトルには他にも
- ``http``
- ``https``
- ``ftp``
- ``smtp``などがあります。
<br>

- **ドメイン**はIPアドレスを人間が読みやすいようにしたものなので、インターネットやローカルネットワーク上でコンピュータやデバイスを識別するための「住所」です。今回はGoogleのサーバーを指定しています。

- **パス**はGoogleサーバーの特定のファイルの場所を表してくれています。このような階層構造です。

```
ルート（https://www.google.co.jp/）
└── images/
    └── branding/
        └── googlelogo/
            └── 2x/
                └── googlelogo_color_272x92dp.png
```

まとめると、
**「暗号化した通信で、Googleサーバーのこのパスが示すファイルを下さい」**
と言っているはずです。


なので、以下のリクエストを送信すると、Googleのロゴ画像が見れるはずです。

https://www.google.co.jp/images/branding/googlelogo/2x/googlelogo_color_272x92dp.png


次です。
![image.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/3924509/264e9e4e-92e0-6a2e-bc68-3f11a2d45b71.png)


#### Request Method :
**GETメソッド**：データを取得するためのメソッドです。
データの送信するときは、URLの後ろにクエリパラメータとしてデータを付与して送信するという特徴があります。

比較対象として、**POSTメソッド**は、データをHTTPリクエストのメッセージボディに含めて送信するという特徴があります。主にデータの送信・登録が目的です。

---

#### 状態コード
「**200 OK**」と書いてありますが、これは先ほど紹介した**HTTPステータスコード**を表しています。

---
#### リモート アドレス : ``[2404:6800:4004:825::2003]:443``
これは**IPアドレス**と**ポート番号**を表しています。

このIPアドレスは**Googleのサーバー**を示していて、**443**はHTTPS通信に使われる標準的なポート番号です。


ポート番号は特定のサービスやプロトコルを識別するための仕組みです。
    IPアドレスで特定したサーバー内の「どのサービス（アプリケーションやプロコトル）」を利用するかを識別するために使われます。

IPアドレスは建物の住所で、ポート番号は部屋番号みたいな例えがあると思いますが、

今回の例でいうと、

:::note info
「**Googleサーバー**の**安全にウェブを見に行く部屋**に行ってくる」
:::
と言っているはずです。

ちなみに、
HTTP通信はポート番号：80 です。

## リクエストヘッダーを見てみる
![image.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/3924509/711a8128-5c79-8e56-1b4b-4a67833a3d84.png)

``authority`` : ホストは``www.google.com``
``method``: GETメソッド
``path`` : `` /images/branding/googlelogo/2x/googlelogo_color_272x92dp.png``
``scheme``: https


``Cache-Control``: ``no-cache``
``Cookie``: ``長々となんか書いてある``

先ほどまでの説明で上の4つは大体わかるはずです。

``Cache-Control``ヘッダーは、キャッシュに関する指示をサーバーに伝えます。
``no-cache`` は、キャッシュされたコンテンツを使わず、**必ずサーバーに対して新しいリソースをリクエストすることを意味します。** ここでは、クライアントが最新のリソースを確実に取得したいという要求が示されています。
更新頻度の高い情報にアクセスするときなどに使われます。


#### ``Cookie``
Cookieはブラウザを識別するために使われます。
WebサーバーがCookieを渡し、Webブラウザが接続時、サーバーにそのCookieを送信することで相手を識別することができる。




## レスポンスヘッダーを確認してみる
![image.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/3924509/1461ae79-8307-031c-206f-ec274be04608.png)

たくさんありますが、一部抜粋しながら解説していきます。

#### ``Cache-Control`` 
- ``private``:クライアントのみがリソースをキャッシュできるようにしています
- ``max-age=秒数``:キャッシュが有効な秒数を指定しています。今回は315360000秒＝1年間のキャッシュができることを表しています。

#### ``Expires`` : 
- キャッシュの有効期限を具体的な日時で指定しています。
- ただし、``Cache-Control``の``max-age``と併用された場合、``Cache-Control``が優先されます。

#### ``Last-Modified`` : 
- リソースが最後に変更された日時を示します。
- これは条件付きリクエストとして利用されます。クライアントがリソースを再取得する場合、``If-Modified-Since``ヘッダーを送ることで、変更があった場合のみリソースを再送信するという仕組みができます。実際のデータのやり取りではないので処理が軽く効率的というメリットがあります。


## 最後に

まだまだHTTPヘッダーの中でも一部しか確認できていないと思いますが、少しずつ意味を理解して、活用できる幅を広げていきたいと思います。


最後までお読みいただきありがとうございました！

## おまけ

![image.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/3924509/4f9936d3-22e1-1643-807a-d6f8208232f7.png)

一見上で紹介したのと同じ画像ですが、この画像のURLは以下のようになっています。

``https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/3924509/4f9936d3-22e1-1643-807a-d6f8208232f7.png``

このURLのドメインは、**Qiita**が画像などのファイルを **AWS S3** サービスを使用して、**東京リージョン（ap-northeast-1)** で保存し、提供していることを示しています。

Qiitaの記事に画像を張り付けると、Googleのサーバーに存在する画像ファイルを参照しに行くのではなくて、Qiita側（AWS側）に画像データが登録されて、そこを参照しに行くみたいですね。

面白いですね

## 参考文献

https://www.amazon.co.jp/%E3%82%A4%E3%83%A9%E3%82%B9%E3%83%88%E5%9B%B3%E8%A7%A3%E5%BC%8F-%E3%81%93%E3%81%AE%E4%B8%80%E5%86%8A%E3%81%A7%E5%85%A8%E9%83%A8%E3%82%8F%E3%81%8B%E3%82%8BWeb%E6%8A%80%E8%A1%93%E3%81%AE%E5%9F%BA%E6%9C%AC-%E7%AC%AC2%E7%89%88-NRI%E3%83%8D%E3%83%83%E3%83%88%E3%82%B3%E3%83%A0%E6%A0%AA%E5%BC%8F%E4%BC%9A%E7%A4%BE/dp/4815625948/ref=pd_lpo_d_sccl_1/355-3933582-3424357?pd_rd_w=AhJhX&content-id=amzn1.sym.855d8f70-df76-4181-80b0-56e48ae3bb9b&pf_rd_p=855d8f70-df76-4181-80b0-56e48ae3bb9b&pf_rd_r=D307NJM85KB10QAVWPWR&pd_rd_wg=weMQa&pd_rd_r=0de1d0a3-8e1c-4643-b540-6301b89668eb&pd_rd_i=4815625948&psc=1







